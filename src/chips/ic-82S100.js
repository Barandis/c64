// Copyright (c) 2020 Thomas J. Otterson
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

// An emulation of the 82S100 Programmable Logic Array, as it was programmed for early
// Commodore 64s.
//
// The 82S100 is a programmable logic chip made by Signetics and is regarded as the very
// first programmable logic device, first released in 1975. It took 16 inputs and could form
// up to 48 product terms (P-terms) by logically ANDind and NOTing selections of the 16
// inputs. These P-terms were then fed to another array that would logically OR them
// selectively, producing up to 8 sum terms (S-terms) that were ultimately sent to the
// output pins (possibly after NOTing them first). The programming for these P- and S-terms
// could be done in the field in a similar manner to that of a PROM (programmable read-only
// memory), and Commodore would program them as a part of production of the C64.
//
// A single 82S100 could therefore serve the same function as a large number of 7400-series
// logic devices, for instance. It was used in a vast array of machines, including other
// Commodore computers and disk drives and those from several other companies. The
// differences between the 82S100's used in each would be the programming of the logic
// arrays.
//
// CBM eventually created their own hard-coded versions of the 82S100, which were faster and
// were cheaper for CBM to produce than it was for them to buy and program 82S100's. The
// schematic from which this emulation is being produced is an early one, from July, 1982,
// and at that time the C64 was still using the Signetics device.
//
// The input pins of the 82S100 were generically named I0-I15, and the output pins were
// similarly named F0-F7. That has been maintained here, though constants are provided to be
// able to use the more C64-centric names that reflect the pins' actual functions in that
// computer.
//
// This chip was tasked with providing the chip enable signals for the C64's RAM and color
// RAM; BASIC, kernal, and character ROM; registers from the 6526 CIAs, 6567 VIC, and 6581
// SID; and two banks of cartridge ROM and two banks of cartridge I/O memory. The 6510
// processor, having a 16-bit address bus, could access 64k of memory, but all of this RAM
// and ROM together added up to closer to 84k. Therefore the PLA used a combination of
// inputs, including some of the address bus, the specialized 6510 I/O port bus, and signals
// from the VIC and cartridge ROMs to determine which memory was trying to be accessed at
// any given time, and then provide chip enable signals for that memory (turning it on and
// turning other memory that could be at the same address off). It would do this for every
// memory access, which would happen twice per cycle (half the cycle was used by the CPU,
// half by the VIC). Thus bank switching actually happened at a frequency of 2MHz, twice the
// CPU clock frequency, and the chip generated a fair bit of heat.
//
// The purpose of the logic in the PLA is to take the current state of the system during a
// memory access and produce a single output enabling the one device (memory chip, processor
// chip with register, cartridge, etc.) that will handle that memory access. (If the
// selected output is IO, that indicates that the I/O block of memory is being accessed, but
// the PLA cannot determine *which* device is being accessed from this information alone.
// When that happens, a separate demultiplexer uses A8-A11 to determine which device it is.)
//
// ### Input pin assignments
//
// * I0: CAS. This is the control line from the VIC that enables access to RAM. Instead of
//     going directly to RAM, this line comes to the PLA and if RAM access is selected, the
//     CASRAM output is sent to the RAM chips.
// * I1: LORAM. This line controls the memory block from 0xa000 - 0xbfff. When high
//     (normal), the BASIC ROM is available in this memory block. When low, it's switched
//     out for RAM.
// * I2: HIRAM. This line controls the memory area from 0xe000 - 0xffff. When high (normal),
//     the KERNAL ROM is available in this memory block. When low, it's switched out for
//     RAM.
// * I3: CHAREN. This line partially controls the memory block from 0xd000 - 0xdfff. When
//     high (normal), the I/O devices appear in this memory block. When low, the character
//     ROM appears here instead. This line can be overridden by other signals, including
//     those allowing this memory block to contain RAM instead.
// * I4, I14-I15: VA14, VA13, and VA12. When the VIC is active, these are used to determine
//     which block of memory the VIC is trying to access. VA14 is active low because that's
//     the way it's generated by CIA2; it's inverted back into active high before being used
//     to access memory but not for use with the PLA.
// * I5-I8: A15-A12. Used to determine which block of memory the CPU wishes to access while
//     the CPU is active.
// * I9: BA. The VIC sets this "Bus Available" line high to indicate normal bus operation,
//     switching between VIC and CPU each cycle. The VIC sets it low when it intends to take
//     exclusive access of the address bus.
// * I10: AEC. This inverse of the VIC's "Address Enable Control" signal indicates which of
//     the CPU (low) or VIC (high) is in control of the data bus.
// * I11: R_W. A high signal means that memory is being read, while a low means memory is
//     being written. This makes a difference to what memory is being accessed. For example,
//     ROM cannot be written; if an attempt is made to write to a ROM address while ROM is
//     banked in, the write will happen to RAM instead.
// * I12-I13: GAME and EXROM. These are used by cartridges to indicate the presence of
//     addressable memory within them. There are two for-sure states for these two signals:
//     if both are high (the normal state), there is no cartridge; and if EXROM is high and
//     GAME is low, there is an Ultimax cartridge. Further mapping to cartridge ROM depends
//     not only on these two signals but also on LORAM, HIRAM, and CHAREN` there is a nice
//     table at https://www.c64-wiki.com/wiki/Bank_Switching#Mode_Table.
//
// ### Output pin assignments
//
// Since the outputs are fed to chip select pins, which are universally active low, all of
// these are programmed to be inverted. Thus, at last seven of them will be high at any
// given time and at most one will be low.
//
// * F0: CASRAM. This is the signal that ultimately enables RAM. The production of this
//     signal is very different from the others. For all other output, if one of their terms
//     is selected, that output will be selected. For CASRAM, its terms are combined with
//     the terms from all other outputs (except for GR_W), and if any of the terms are
//     selected, then CASRAM will be *de*selected. (Even if all of those other outputs are
//     deselected, CASRAM will be deselected if CAS is high or if certain addresses are
//     accessed while an Ultimax cartridge is plugged in. In these cases, no PLA outputs
//     will be selected.)
// * F1: BASIC. Enables the BASIC ROM.
// * F2: KERNAL. Enables the KERNAL ROM.
// * F3: CHAROM. Enables the Character ROM.
// * F4: GR_W. Indicates that the static color RAM is being written to. Note that this is
//     the only output that is not actually a chip enable signal; color RAM is possibly
//     enabled if the IO output is selected (see the Ic74139 for details).
// * F5: IO. Indicates that one of the following are going to be enabled: CIA1 registers,
//     CIA2 registers, VIC registers, SID registers, color RAM, expansion port I/O from
//     address 0xde00 - 0xdeff, or expansion port I/O from address 0xdf00 - 0xdfff. Which of
//     these is actually enabled is done by decoding A8-A11, which is done by the 74139.
// * F6: ROML. Enables expansion port ROM from 0x8000 - 0x9fff.
// * F7: ROMH. Enables expansion port ROM from 0xe000 - 0xefff.
//
// There is a ton of information about the internal workings of the C64's version of the
// 82S100 in "The C64 PLA Dissected" at
// http://skoe.de/docs/c64-dissected/pla/c64_pla_dissected_a4ds.pdf. This document was used
// to derive all of the logic in this object and has a number of interesting stories besides
// (if you find that sort of thing interesting).
//
// Additionally, the 82S100 has an active-low chip enable pin CE which is not used in the
// Commodore 64 (it is tied directly to ground and therefore is always low, so the chip is
// always enabled). There is also an FE pin that was used for programming the chip in the
// field; the emulated chip from the C64 doesn't use this as the chip was programmed during
// manufacturing.
//
// The chip comes in a 28-pin dual in-line package with the following pin assignments.
//
//         +-----+--+-----+
//      FE |1    +--+   28| Vcc
//      I7 |2           27| I8
//      I6 |3           26| I9
//      I5 |4           25| I10
//      I4 |5           24| I11
//      I3 |6           23| I12
//      I2 |7           22| I13
//      I1 |8   82S100  21| I14
//      I0 |9           20| I15
//      F7 |10          19| CE
//      F6 |11          18| F0
//      F5 |12          17| F1
//      F4 |13          16| F2
//     Vss |14          15| F3
//         +--------------+
//
// The pin assignments are very straightforward and are described here.
//
// | Pin | Name  | C64 Name | Description                                                  |
// | --- | ----- | -------- | ------------------------------------------------------------ |
// | 1   | FE    |          | Field programming pin. Used to program a PLA in the field.   |
// |     |       |          | This pin is left unconnected in normal use and is not        |
// |     |       |          | emulated.                                                    |
// | --- | ----- | -------- | ------------------------------------------------------------ |
// | 2   | I7    | A13      | Input pins. These are connected to traces in the C64 that    |
// | 3   | I6    | A14      | are described by their C64 name. Each of these traces is     |
// | 4   | I5    | A15      | instrumental in determining which chip should be enabled for |
// | 5   | I4    | VA14     | the next read or write. Details of the purpose for each of   |
// | 6   | I3    | CHAREN   | these are desribed above.                                    |
// | 7   | I2    | HIRAM    |                                                              |
// | 8   | I1    | LORAM    |                                                              |
// | 9   | I0    | CAS      |                                                              |
// | 20  | I15   | VA12     |                                                              |
// | 21  | I14   | VA13     |                                                              |
// | 22  | I13   | GAME     |                                                              |
// | 23  | I12   | EXROM    |                                                              |
// | 24  | I11   | R_W      |                                                              |
// | 25  | I10   | AEC      |                                                              |
// | 26  | I9    | BA       |                                                              |
// | 27  | I8    | A12      |                                                              |
// | --- | ----- | -------- | ------------------------------------------------------------ |
// | 10  | F7    | ROMH     | Output pins. Each of these is active-low and leads to the    |
// | 11  | F6    | ROML     | chip select pins of the chip (or expansion port pin, in the  |
// | 12  | F5    | IO       | case of ROML and ROMH) described by its C64 name. Details    |
// | 13  | F4    | GR_W     | about the purpose for each of these signals is described     |
// | 15  | F3    | CHAROM   | above.                                                       |
// | 16  | F2    | KERNAL   |                                                              |
// | 17  | F1    | BASIC    |                                                              |
// | 18  | F0    | CASRAM   |                                                              |
// | --- | ----- | -------- | ------------------------------------------------------------ |
// | 14  | GND   |          | Electrical ground. Not emulated.                             |
// | --- | ----- | -------- | ------------------------------------------------------------ |
// | 19  | CE    |          | Active-low chip enable. Always low (enabled) in the C64.     |
// | --- | ----- | -------- | ------------------------------------------------------------ |
// | 28  | Vcc   |          | +5V power supply. Not emulated.                              |
//
// In the Commodore 64, U17 is an 82S100. As detailed extensively above, it was used to
// decode signals to determine which chip would receive a particular read or write.

import Chip from 'components/chip'
import Pin from 'components/pin'
import Pins from 'components/pins'

const { INPUT, OUTPUT } = Pin

// These are alternate names for the input (I) and output (F) pins, matching purpose of each
// pin in the Commodore 64. They can be used to access the same pins with a different naming
// convention. For example, the I0 pin, which accepts the CAS signal from the VIC, can be
// accessed regularly with `chip.pins.I0` or `chip.pins[9]`. With these constants, if so
// desired, it can also be accessed as `chip.pins[CAS]`.
export const CAS = 'I0'
export const LORAM = 'I1'
export const HIRAM = 'I2'
export const CHAREN = 'I3'
export const VA14 = 'I4'
export const A15 = 'I5'
export const A14 = 'I6'
export const A13 = 'I7'
export const A12 = 'I8'
export const BA = 'I9'
export const AEC = 'I10'
export const R_W = 'I11'
export const EXROM = 'I12'
export const GAME = 'I13'
export const VA13 = 'I14'
export const VA12 = 'I15'
export const CASRAM = 'F0'
export const BASIC = 'F1'
export const KERNAL = 'F2'
export const CHAROM = 'F3'
export const GR_W = 'F4'
export const IO = 'F5'
export const ROML = 'F6'
export const ROMH = 'F7'

export default function Ic82S100() {
  const pins = Pins(
    // Input pins. In the 82S100, these were generically named I0 through I15, since each
    // pin could serve any function depending on the programming applies.
    Pin(9, 'I0', INPUT),
    Pin(8, 'I1', INPUT),
    Pin(7, 'I2', INPUT),
    Pin(6, 'I3', INPUT),
    Pin(5, 'I4', INPUT),
    Pin(4, 'I5', INPUT),
    Pin(3, 'I6', INPUT),
    Pin(2, 'I7', INPUT),
    Pin(27, 'I8', INPUT),
    Pin(26, 'I9', INPUT),
    Pin(25, 'I10', INPUT),
    Pin(24, 'I11', INPUT),
    Pin(23, 'I12', INPUT),
    Pin(22, 'I13', INPUT),
    Pin(21, 'I14', INPUT),
    Pin(20, 'I15', INPUT),

    // Output pins. Similar to the input pins, these were named generically on the 82S100.
    Pin(18, 'F0', OUTPUT).clear(),
    Pin(17, 'F1', OUTPUT).set(),
    Pin(16, 'F2', OUTPUT).set(),
    Pin(15, 'F3', OUTPUT).set(),
    Pin(13, 'F4', OUTPUT).set(),
    Pin(12, 'F5', OUTPUT).set(),
    Pin(11, 'F6', OUTPUT).set(),
    Pin(10, 'F7', OUTPUT).set(),

    // Output enable, disables all outputs when set high.
    Pin(19, 'OE', INPUT),

    // Field programming pin, not used in mask programmed parts and not emulated.
    Pin(1, 'FE'),

    // Power supply pins, not emulated.
    Pin(28, 'VCC'),
    Pin(14, 'GND'),
  )

  // What else are you going to call an event listener that's 258 lines long?
  const oneListener = () => {
    if (pins.OE.high) {
      pins.F0.float()
      pins.F1.float()
      pins.F2.float()
      pins.F3.float()
      pins.F4.float()
      pins.F5.float()
      pins.F6.float()
      pins.F7.float()

      return
    }

    const i0 = pins.I0.high
    const i1 = pins.I1.high
    const i2 = pins.I2.high
    const i3 = pins.I3.high
    const i4 = pins.I4.high
    const i5 = pins.I5.high
    const i6 = pins.I6.high
    const i7 = pins.I7.high
    const i8 = pins.I8.high
    const i9 = pins.I9.high
    const i10 = pins.I10.high
    const i11 = pins.I11.high
    const i12 = pins.I12.high
    const i13 = pins.I13.high
    const i14 = pins.I14.high
    const i15 = pins.I15.high

    // These are the product term equations programmed into the PLA for use in a C64. The
    // names for each signal reflect the names of the pins that those signals come from, and
    // while that is an excellent way to make long and complex code succinct, it doesn't do
    // much for the human reader. For that reason, each term has a comment to describe in
    // more human terms what is happening with that piece of the algorithm.
    //
    // Each P-term below has a comment with three lines. The first line describes the state
    // of the three 6510 I/O port lines that are used for bank switching (LORAM, HIRAM, and
    // CHAREN). The second line is the memory address that needs to be accessed to select
    // that P-term (this is from either the regular address bus when the CPU is active or
    // the VIC address bus when the VIC is active). The final line gives information about
    // whether the CPU or the VIC is active, whether the memory access is a read or a write,
    // and what type (if any) of cartridge must be plugged into the expansion port (the
    // cartridge informaion takes into account the values of LORAM, HIRAM, and CHAREN
    // already).
    //
    // If any piece of information is not given, its value doesn't matter to that P-term.
    // For example, in p0, the comment says that LORAM and HIRAM must both be deselected.
    // CHAREN isn't mentioned because whether it is selected or not doesn't change whether
    // that P-term is selected or not.
    //
    // Oftentimes, the reason for multiple terms for one output selection is the limitation
    // on what can be checked in a single logic term, given that no ORs are possible in the
    // production of P-terms. For example, it is very common to see two terms that are
    // identical except that one indicates "no cartridge or 8k cartridge" while the other
    // has "16k cartridge". These two terms together really mean "anything but an Ultimax
    // cartridge", but there's no way to do that in a single term with only AND and NOT.
    //
    // This information comes from the excellent paper available at
    // skoe.de/docs/c64-dissected/pla/c64_pla_dissected_a4ds.pdf. If this sort of thing
    // interests you, there's no better place for information about the C64 PLA.

    // LORAM deselected, HIRAM deselected
    // 0xa000 - 0xbfff
    // CPU active, Read, No cartridge or 8k cartridge
    const p0 = i1 & i2 & i5 & !i6 & i7 & !i10 & i11 & i13

    // HIRAM deselected
    // 0xe000 - 0xffff
    // CPU active, Read, No cartridge or 8k cartridge
    const p1 = i2 && i5 && i6 && i7 && !i10 && i11 && i13

    // HIRAM deselected
    // 0xe000 - 0xffff
    // CPU active, Read, 16k cartridge
    const p2 = i2 && i5 && i6 && i7 && !i10 && i11 && !i12 && !i13

    // HIRAM deselected, CHAREN selected
    // 0xd000 - 0xdfff
    // CPU active, Read, No cartridge or 8k cartridge
    const p3 = i2 && !i3 && i5 && i6 && !i7 && i8 && !i10 && i11 && i13

    // LORAM deselected, CHAREN selected
    // 0xd000 - 0xdfff
    // CPU active, Read, No cartridge or 8k cartridge
    const p4 = i1 && !i3 && i5 && i6 && !i7 && i8 && !i10 && i11 && i13

    // HIRAM deselected, CHAREN selected
    // 0xd000 - 0xdfff
    // CPU active, Read, 16k cartridge
    const p5 = i2 && !i3 && i5 && i6 && !i7 && i8 && !i10 && i11 && !i12 && !i13

    //
    // 0x1000 - 0x1fff or 0x9000 - 0x9fff
    // VIC active, No cartridge or 8k cartridge
    const p6 = i4 && !i14 && i15 && i10 && i13

    //
    // 0x1000 - 0x1fff or 0x9000 - 0x9fff
    // VIC active, 16k cartridge
    const p7 = i4 && !i14 && i15 && i10 && !i12 && !i13

    // Unused. May be a relic from earlier design in C64 prototypes that never got removed.
    // const p8 = i0 && i5 && i6 && !i7 && i8 // && !i10 && !i11

    // HIRAM deselected, CHAREN deselected
    // 0xd000 - 0xdfff
    // CPU active, Bus available, Read, No cartridge or 8k cartridge
    const p9 = i2 && i3 && i5 && i6 && !i7 && i8 && !i10 && i9 && i11 && i13

    // HIRAM deselected, CHAREN deselected
    // 0xd000 - 0xdfff
    // CPU active, Write, No cartridge or 8k cartridge
    const p10 = i2 && i3 && i5 && i6 && !i7 && i8 && !i10 && !i11 && i13

    // LORAM deselected, CHAREN deselected
    // 0xd000 - 0xdfff
    // CPU active, Bus available, Read, No cartridge or 8k cartridge
    const p11 = i1 && i3 && i5 && i6 && !i7 && i8 && !i10 && i9 && i11 && i13

    // LORAM deselected, CHAREN deselected
    // 0xd000 - 0xdfff
    // CPU active, Write, No cartridge or 8k cartridge
    const p12 = i1 && i3 && i5 && i6 && !i7 && i8 && !i10 && !i11 && i13

    // HIRAM deselected, CHAREN deselected
    // 0xd000 - 0xdfff
    // CPU active, Bus available, Read, 16k cartridge
    const p13 = i2 && i3 && i5 && i6 && !i7 && i8 && !i10 && i9 && i11 && !i12 && !i13

    // HIRAM deselected, CHAREN deselected
    // 0xd000 - 0xdfff
    // CPU active, Write, 16k cartridge
    const p14 = i2 && i3 && i5 && i6 && !i7 && i8 && !i10 && !i11 && !i12 && !i13

    // LORAM deselected, CHAREN deselected
    // 0xd000 - 0xdfff
    // CPU active, Bus available, Read, 16k cartridge
    const p15 = i1 && i3 && i5 && i6 && !i7 && i8 && !i10 && i9 && i11 && !i12 && !i13

    // LORAM deselected, CHAREN deselected
    // 0xd000 - 0xdfff
    // CPU active, Write, 16k cartridge
    const p16 = i1 && i3 && i5 && i6 && !i7 && i8 && !i10 && !i11 && !i12 && !i13

    //
    // 0xd000 - 0xdfff
    // CPU active, Bus available, Read, Ultimax cartridge
    const p17 = i5 && i6 && !i7 && i8 && !i10 && i9 && i11 && i12 && !i13

    //
    // 0xd000 - 0xdfff
    // CPU active, Write, Ultimax cartridge
    const p18 = i5 && i6 && !i7 && i8 && !i10 && !i11 && i12 && !i13

    // LORAM deselected, HIRAM deselected
    // 0x8000 - 0x9fff
    // CPU active, Read, 8k or 16k cartridge
    const p19 = i1 && i2 && i5 && !i6 && !i7 && !i10 && i11 && !i12

    //
    // 0x8000 - 0x9fff
    // CPU active, Ultimax cartridge
    const p20 = i5 && !i6 && !i7 && !i10 && i12 && !i13

    // HIRAM deselected
    // 0xa000 - 0xbfff
    // CPU active, Read, 16k cartridge
    const p21 = i2 && i5 && !i6 && i7 && !i10 && i11 && !i12 && !i13

    //
    // 0xe000 - 0xefff
    // CPU active, Ultimax cartridge
    const p22 = i5 && i6 && i7 && !i10 && i12 && !i13

    //
    // 0x3000 - 0x3fff, 0x7000 - 0x7fff, 0xb000 - 0xbfff, or 0xe000 - 0xefff
    // VIC active, Ultimax cartridge
    const p23 = i14 && i15 && i10 && i12 && !i13

    //
    // 0x1000 - 0x1fff or 0x3000 - 0x3fff
    // Ultimax cartridge
    const p24 = !i5 && !i6 && i8 && i12 && !i13

    //
    // 0x2000 - 0x3fff
    // Ultimax cartridge
    const p25 = !i5 && !i6 && i7 && i12 && !i13

    //
    // 0x4000 - 0x7fff
    // Ultimax cartridge
    const p26 = !i5 && i6 && i12 && !i13

    //
    // 0xa000 - 0xbfff
    // Ultimax cartridge
    const p27 = i5 && !i6 && i7 && i12 && !i13

    //
    // 0xc000 - 0xcfff
    // Ultimax cartridge
    const p28 = i5 && i6 && !i7 && !i8 && i12 && !i13

    // Unused.
    // const p29 = !i1

    // CAS deselected
    //
    //
    const p30 = i0

    // CAS selected
    // 0xd000 - 0xdfff
    // CPU access, Write
    const p31 = !i0 && i5 && i6 && !i7 && i8 && !i10 && !i11

    // This is the sum-term (S-term) portion of the logic, where the P-terms calculated
    // above are logically ORed to poroduce a single output. This is much simpler than
    // P-term production because the P-terms handle everything about chip selection, except
    // that each chip may be the choice of several different P-terms. That's the role of the
    // S-term logic, to combine P-terms to come up with single outputs.

    // Selects BASIC ROM.
    const s1 = p0

    // Selects KERNAL ROM.
    const s2 = p1 || p2

    // Selects Character ROM.
    const s3 = p3 || p4 || p5 || p6 || p7

    // Selects I/O, color RAM, or processor registers.
    const s4 = p9 || p10 || p11 || p12 || p13 || p14 || p15 || p16 || p17 || p18

    // Selects low cartridge ROM.
    const s5 = p19 || p20

    // Selects high cartridge ROM.
    const s6 = p21 || p22 || p23

    // Selects write mode for color RAM.
    const s7 = p31

    // Deselects RAM. This is the only *de*selection, which is why it is the only one not
    // inverted in the state assignment below.
    const s0 = s1 || s2 || s3 || s4 || s5 || s6 || p24 || p25 || p26 || p27 || p28 || p30

    pins.F0.level = s0
    pins.F1.level = !s1
    pins.F2.level = !s2
    pins.F3.level = !s3
    pins.F4.level = !s7
    pins.F5.level = !s4
    pins.F6.level = !s5
    pins.F7.level = !s6
  }

  pins.OE.addListener(oneListener)
  pins.I0.addListener(oneListener)
  pins.I1.addListener(oneListener)
  pins.I2.addListener(oneListener)
  pins.I3.addListener(oneListener)
  pins.I4.addListener(oneListener)
  pins.I5.addListener(oneListener)
  pins.I6.addListener(oneListener)
  pins.I7.addListener(oneListener)
  pins.I8.addListener(oneListener)
  pins.I9.addListener(oneListener)
  pins.I10.addListener(oneListener)
  pins.I11.addListener(oneListener)
  pins.I12.addListener(oneListener)
  pins.I13.addListener(oneListener)
  pins.I14.addListener(oneListener)
  pins.I15.addListener(oneListener)

  return Chip(pins)
}
